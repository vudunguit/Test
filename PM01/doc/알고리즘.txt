1. 빗자루 수량 계산 알고리즘
- 빗자루 수량이 6보다 크거나 같을 경우는 시간 세팅이 필요없다.
1) HomeTop.java
- 현재 빗자루 수량을 가져와서 6보다 크거나 같으면 6을 표시하고 00:00으로 표시.
  수량이 6을 넘는 경우는 시간 세팅을 할필요가 없다.
- 가져온 빗자루 수량이 6보다 작은 경우 예를 들어 3이라고 가정한다면,
  가장 마지막에 플레이한 시간을 가져와서 현재시간까지의 경과시간을 계산한다.
  예로, 만일 경과시간이 36분이라고 가정한다면 빗자루 수량은 2를 증가시켜서 5로 표시하고, 
        시간은 6분이 남아있으므로 현재시간에서 6분을 뺀 시간을 pref에 저장하고,
        display 시간은 15분 - 6분 = 9분을 표시한다.
  예로, 만일 경과시간이 24시간이라고 가정하면 빗자루 수량을 현재 3에서 3을 더해서 6을 표시하고,
        display 시간은 00:00, 시간은 세팅할 필요가 없다.
2) GameLoading.java 진입시
- 만일 빗자루 수량이 6보다 크거나 같을 경우는 1을 빼서 5를 DB에 저장하고,
  그리고 현재 시간을 세팅한다.
- 만일 빗자루 수량이 6보다 작을 경우는 1을 빼서 DB에 저장하기만 하면 된다.
  시간은 이미 세팅되어 있으므로 세팅할 필요가 없다.
 
 2. 아이템 구매 알고리즘
 1)골드, 빗자루 구매시 현재 시간을 mili second 을 유니크한 키값으로 해서 DB에 저장한다.
 DB에 저장시에는 유니크한 키값이 존재한 가능성이 아주 희박하지만 있으므로
 먼저 select 구문을 돌려서 해당 키값이 있는지를 조사하고 없다면 insert하고,
 있다면 키값에 1을 증가시켜서 다시 select 한다. 해당 키값이 없다면 insert하고, 
 다시 1을 증가시켜서 해당로직을 10번 반복 수행하도록 한다.
 2) 만일 아이템을 친구에게 선물할 시에는 페이스북 invite API를 사용하여 선물한 내용을 
 알람으로 알려준다. 
 
 3. 타일 오픈 알고리즘
 아이폰과 동일한 알고리즘이 안된다면,,,
 현재 open()함수를 재귀함수로 계속 자신을 호출하는 알고리즘은 그대로 두고,
 타일이 벗겨지는 수량을 카운트하여 타일 4개당 하나의 단음 사운드를 내도록 한다.     
 만일 타일 100개가 벗겨진다면 25개의 단음 사운드를 연속으로 호출하여 
 도-레-미-파-솔-라-시-도- .... 로 점점 높아지는 사운드 효과를 낸다.  
 
 4. 게임 엔딩시 경험치와 레벨업 팝업 애니메이션 로직
 게임 경험치 1000당 1000ms를 움직이게 한다.
 예를 들어 현재 레벨이 1이고 현재 경험치가 3000이고 1레벨 경험치 max가 7000이라고 하고,
 획득한 경험치가 6000이라고 가정하면,
 경험치가 7000에 도달할때까지 4000의 경험치가 필요하므로 4000ms 동안 경험치 증가 애니메이션을 구동하고,
 레벨up 팝업을 3초간 띄운다.
 그리고, 남은 경험치 2000을 2초동안 애니메이션 시켜준다.
 
 4. Game.java
 GameLoading은 지금 별도의 씬인데, Game에 컴포지션으로 포함시켜야 로딩바 구현이가능함
 전체 구조를 그리면 아래와 같다.
 하위 레이어를 생성시 인스턴스를 주입시켜서 하위레이어가 상위레이어를 접근가능하게 한다. 델리게이트는 필요없음
 Game - GameLoading
      |
      - MineCell
      |
      - HudLayer - GameProgressBar
                 |
                 - GameMiniMap
                 |
                 - GameEnding
                 

*temp 
private void startVictory() {
    		CCSprite backLight = CCSprite.sprite("70game_ending/back-light.png");
    		CCSprite backSearch = CCSprite.sprite("70game_ending/back-search.png");
    		CCSprite rybon = CCSprite.sprite("70game_ending/rybon.png");
    		
    		//백라이트 배치
    		addChild(backLight);
    		backLight.setPosition(width*0.5f, height*0.5f);
    		
    		//회전 섬광 배치
    		addChild(backSearch);
    		backSearch.setPosition(width*0.5f, height*0.5f);
    		
    		//리본 배치
    		rybon.setPosition(width*0.5f, height*0.5f);
    		addChild(rybon);
    		
    		//별배치
    		for (int i = 0; i< 100 ; i++) {
	    		CCSprite star = CCSprite.sprite("70game_ending/star.png");
	    		
	    		CCDelayTime delay = CCDelayTime.action(new Random().nextFloat() * 5.0f);
	    		CCCallFuncN show = CCCallFuncN.action(this, "cbShowSprite");
	    		star.runAction(CCSequence.actions(delay, show));
    		}
    		
    		//배경 회전
    		CCRotateBy rot = CCRotateBy.action(4, 360);
    		CCCallFuncN end = CCCallFuncN.action(this, "cbEndVictory");
    		backSearch.runAction(rot);
    		
    		//리본 확대->축소 
    		rybon.setScale(1.5f);
    		CCScaleTo scale = CCScaleTo.action(0.5f, 1.0f);
    		CCCallFuncN call = CCCallFuncN.action(this, "cbCallHeartLeft");
    		rybon.runAction(CCSequence.actions(scale, call));
    	}
    	
    	public void cbShowSprite(Object sender) {
    		CCSprite star = (CCSprite) sender;
    		//star.setOpacity(0);
    		star.setScale(0.5f +  new Random().nextFloat()*1.0f);
    		star.setPosition(new Random().nextFloat()*width, new Random().nextFloat()*height);
    		
    		//CCFadeIn in = CCFadeIn.action(1.0f);
    		CCFadeOut out = CCFadeOut.action(1.0f);
    		CCCallFuncN remove = CCCallFuncN.action(this, "cbRemoveSprite");
    		addChild(star);
    		star.runAction(CCSequence.actions(out, remove));
    	}
    	
    	public void cbEndVictory(Object sender) {
    		Log.d("LDK", "cbEndVictory");
    	}
    	
    	public void cbCallHeartLeft(Object sender) {
    		CCSprite heartLeft = CCSprite.sprite("70game_ending/heart-left.png");
    		addChild(heartLeft);
    		heartLeft.setPosition(width*0.5f, height*0.5f);
    		
    		heartLeft.setScale(1.5f);
    		CCScaleTo scale = CCScaleTo.action(0.5f, 1.0f);
    		CCCallFuncN call = CCCallFuncN.action(this, "cbCallHeartRight");
    		heartLeft.runAction(CCSequence.actions(scale, call));
    	}
    	
    	public void cbCallHeartRight(Object sender) {
    		CCSprite heartRight = CCSprite.sprite("70game_ending/heart-right.png");
    		addChild(heartRight);
    		heartRight.setPosition(width*0.5f, height*0.5f);
    		
    		heartRight.setScale(1.5f);
    		CCScaleTo scale = CCScaleTo.action(0.5f, 1.0f);
    		CCCallFuncN call = CCCallFuncN.action(this, "cbCallHeartCenter");
    		heartRight.runAction(CCSequence.actions(scale, call));
    	}
    	
    	public void cbCallHeartCenter(Object sender) {
    		CCSprite heartCenter = CCSprite.sprite("70game_ending/heart-center.png");
    		addChild(heartCenter);
    		heartCenter.setPosition(width*0.5f, height*0.5f);
    		
    		heartCenter.setScale(1.5f);
    		CCScaleTo scale = CCScaleTo.action(0.5f, 1.0f);
    		CCCallFuncN call = CCCallFuncN.action(this, "cbCallScore");
    		heartCenter.runAction(CCSequence.actions(scale, call));
    	}
    	
    	public void cbCallScore(Object sender) {
    		int k = 3;
    		CCSprite score = null;
    		if (k == 1) {
    			score = CCSprite.sprite("70game_ending/x1.png");
    		} else if (k == 2) {
    			score = CCSprite.sprite("70game_ending/x2.png");
    		} else {
    			score = CCSprite.sprite("70game_ending/x3.png");
    		}
    		
    		addChild(score);
    		score.setPosition(width*0.5f, height*0.3f);
    		
    		score.setScale(1.5f);
    		CCScaleTo scale = CCScaleTo.action(0.5f, 1.0f);

    		score.runAction(scale);
    	}
      